* Java Basics

~ Variables in Java
- 3 types of variables - Static(1 for all objects of that class), Instance, Local
- Marking a variable public static ==> Global variable.
- Marking a variable public staic final => Global constant.
- Valid variable in java -> alphanumeric and underscore and dollar.
- No object variable --> It is object reference variable.
- Person myPerson = new Person()
    a. allocate space for the reference variable and name it as myPerson
    b. allocate space for the object on heap
    c. assign the object to the myPerson variable.
- All the object reference variable are of the same size, but the size varies according to the JVM.
- Instance variables get default values when not initialised.
  integers=0, float=0.0, boolean=false, reference=null
- Instance variables = defined at class level, get assigned with default values.
  Local variables = defined inside the method, cannot use uninitialised local variables.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Java OOPs concept

* Encapsulation: 
- Combining data members and methods together in form of class.
- Encapsulation ensures data security, maintainability, and flexibility by hiding implementation details and restricting direct access to class variables.
- Data Protection & Security: Prevents unauthorized access by making variables private and exposing only controlled access through public methods.
- Maintains Data Integrity: Allows validation before modifying data (e.g., ensuring age is always positive).
- Improves Code Maintainability: Internal implementation can change without affecting other parts of the application.
- Enhances Modularity: Each class handles its own data, reducing dependencies and improving reusability.

Q. How Does Encapsulation Improve Security?
Encapsulation improves security by restricting direct access to variables and ensuring controlled data modification through methods(e.g., a bank account balance should never be negative).
It prevents unauthorized changes, maintains data integrity, and makes the code more maintainable.

Q. Can we achieve encapsulation without getters and setters?
-> Making fields private, using controlled access methods, constructor injection, and interfaces.

Q. Can encapsulation be broken in Java? If yes, how?
Encapsulation can be broken using Reflection API, which allows access to private fields and methods.

import java.lang.reflect.Field;
class Secret {
    private String secretCode = "12345";  // Private field
}

public class ReflectionDemo {
    public static void main(String[] args) throws Exception {
        Secret obj = new Secret();
        Field field = Secret.class.getDeclaredField("secretCode");
        field.setAccessible(true);  // Bypasses encapsulation
        field.set(obj, "Hacked!");
        System.out.println(field.get(obj));  // Output: Hacked!
    }
}
How to Prevent It?
1️⃣ Use Security Manager – It can restrict Reflection API access.
2️⃣ Mark fields as final – This makes it harder to modify using reflection.
3️⃣ Use sealed classes (Java 15+) – Restricts which classes can extend a class.
4️⃣ Throw an Exception if Reflection is Used

Q. How does encapsulation improve performance in a multi-threaded application?
1. Prevents Race Conditions (Thread-Safe Data Access)
class BankAccount {
    private double balance;  // Private ensures direct access is not possible
    public synchronized void deposit(double amount) {  // Thread-safe
        if (amount > 0) balance += amount;
    }
    public synchronized double getBalance() {  // Thread-safe read operation
        return balance;
    }
}

2. Reduces Synchronization Overhead (the extra time and resources used to manage synchronization)
class Counter {
    private int count;
    public void increment() {  // No unnecessary locking
        synchronized (this) {
            count++;
        }
    }
    public int getCount() {
        return count;
    }
}

3. Supports Immutability (No Synchronization Needed)

Q. How does Encapsulation relate to Immutable Classes in Java?
Encapsulation and Immutability are closely related because encapsulation helps enforce immutability by restricting direct modification of fields.
Steps to Create an Immutable Class:
1️⃣ Declare the class as final (So it can’t be subclassed).
2️⃣ Make all fields private and final (So they can't be modified).
3️⃣ Provide only getters, no setters (No way to change values).
4️⃣ Initialize fields via a constructor (No external modification).
5️⃣ Return defensive copies(a new object with the same values) for mutable fields (Prevents modification of internal objects).

final class ImmutableData {
    private final int value;
    public ImmutableData(int value) {
        this.value = value;
    }
    public int getValue() {
        return value;
    }
}

* Inheritance:
- Allows a class to inherit properties and behaviour from another class.
- Useful for: Code reusability, maintainability, extensibility, establishing relations.
- IS-A relation, B IS-A C, so class B can extend class C.
- HAS-A relation, B HAS-A C, so class B can have an instance variable of class C.
- public members are inherited and private members are not. Use getter/setter methods or protected access if access is needed.
- The methods in the subclass override the parent class methods.
- Constructors are NOT inherited by a subclass.
- Anything that extends the reference variable can be assigned to the reference variable.
    Eg: List<String> myList = new ArrayList<>();

~ Types of inheritance:
1. Single Inheritance
    [Superclass]
         |
         v
     [Subclass]

2. Multilevel Inheritance
    [Grandparent Class]
        |
        v
    [Parent Class]
        |
        v
   [Child Class]

3. Hierarchical Inheritance (multiple classes inherit from a single superclass.)
         [Superclass]
        /            \
       v              v
[Subclass 1]     [Subclass 2]

4. Multiple Inheritance (multiple inheritance is not allowed through classes but for interfaces)
    [Interface 1]  [Interface 2]
        \                /
            v         v
              [Class]

5. Hybrid Inheritance (Multiple and Multi level)
    [Superclass]          [Interface 1]
        |                    |
        v                    v
    [Subclass]           [Interface 2]
           \               /
              v         v
                [Class] 

Eg: class Dog extends Mammal implements Animal, Walker {...}

## Difference Between Method Overriding and Method Overloading

| Feature              | Method Overriding                                           | Method Overloading                           
|----------------------|-------------------------------------------------------------|----------------------------------------------------------------------
| Definition           | Redefining a method in the subclass                         | Defining multiple methods with the same name but different parameters 
| Where it happens?    | Between superclass and subclass                             | Within the same class                      
| Method Signature     | Must have the same method name, return type, and parameters | Must have the same name but different parameter lists 
| Access Modifier      | Cannot reduce the visibility                                | No restrictions on visibility 
| Return Type          | Must be the same (or covariant)                             | Can be different                              
| Static Methods?      | Cannot override `static` methods (hiding happens instead)   | Can overload `static` methods                 
| Runtime/Compile-time | Happens at runtime (dynamic binding)                        | Happens at compile-time (static binding) 

Q. Are Constructors Inherited by a Subclass?
- Constructors are NOT inherited because each class has unique initialization logic.
- A subclass must call a superclass constructor explicitly using super(), otherwise Java automatically calls the default constructor of the superclass.
- If the superclass does not have a default constructor, the subclass must explicitly call one of its parameterized constructors.
- The superclass constructor always executes first to ensure proper initialization.

Q. How Does the super Keyword Work in Java Inheritance?
- Access Superclass Methods
- Access Superclass Fields 
- Call Superclass Constructor (super())
- Java always calls the default constructor of the parent class.
- If a superclass only has a parameterized constructor, the subclass must explicitly call it using super(arguments), otherwise a compilation error occurs.
It is basically an alias for parent class name.

Q. Can a Subclass Override a Static Method from Its Superclass? Why or Why Not?
- No, a subclass cannot override a static method from its superclass.
- If a subclass defines a static method with the same signature, it is called method hiding rather than overriding.
- Static methods belong to the class, not the instance.
- Method overriding relies on runtime polymorphism (dynamic binding), which does not apply to static methods.
- Since startEngine() is static, Vehicle.startEngine() is called based on the reference type (Vehicle). 
- Correct Way to Call a Hidden Static Method is to use the subclass reference: Car.startEngine(); // Output: Car engine started

Eg:
class Vehicle {
    static void startEngine() {
        System.out.println("Vehicle engine started");
    }
}

class Car extends Vehicle {
    static void startEngine() { // This does NOT override the superclass method
        System.out.println("Car engine started");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle myCar = new Car();
        myCar.startEngine(); // Calls Vehicle's method, NOT Car's!
    }
}

* Abstraction:
Hiding details and showing essential things to the user.

Abstraction can be achieved using 2 ways:

1. Abstract class: 
- Defined with an abstract keyword. 
- May or may not have all the abstract methods. Some of them can be concrete methods.
- An abstract method must always be redefined in the subclass, unless the subclass itself is abstract.
- Abstract classes can not be directly instantiated using new operator.
- Abstract class can have parameterised constructor and default constructor is always present.
- Abstract is a java modifier not applicable for variables.
- We can have an abstract class without any abstract method. This allows us to create classes that cannot be instantiated but can only be inherited. 
- There can be final method in an abstract class, but an abstract method can not be declared as final.
- The abstract keyword for declaring top-level classes (Outer class) as well as inner classes as abstract
abstract class B {
    abstract class C {
        abstract void myAbstractMethod();
    }
}
class D extends B {
    class E extends C {
        void myAbstractMethod()
        { System.out.println("Inside abstract method implementation");}
    }
}
public class Main {
    public static void main(String args[])
    {
        D outer = new D();
        D.E inner = outer.new E();
        inner.myAbstractMethod();
    }
}

- Observations in the below example:
1. Abstract class cannot be created, we can have references to abstract class type though.
2. Abstract class can contain constructors in Java. And a constructor of an abstract class is called when an instance of an inherited class is created.
3. Abstract classes can also have final methods (methods that cannot be overridden)
4. We can define static methods in an abstract class that can be called independently without an object.

Eg:
abstract class Base {
    Base(){ System.out.println("Base Constructor Called");}
    abstract void fun();
    final void finalfun(){System.out.println("Base finalfun() called");}
    static void staticfun(){System.out.println("Geeks for Geeks");
}

class Derived extends Base {
    Derived(){System.out.println("Derived Constructor Called");}
    void fun(){ System.out.println("Derived fun() called");}
}

class GFG {
    public static void main(String args[])
    {
        //(1) point
        Base b = new Derived(); //(2) point
        b.fun(); 

        Derived d = new Derived();
        d.finalfun(); //(3) point

        Base.staticfun();     //(4) point
        Derived.staticfun();  //(4) point
    }
}

Output: 
Base Constructor Called
Derived Constructor Called
Derived fun() called
Base finalfun() called


2. Interface:
- Provides 100% abstraction
- Could only have abstract methods (methods without a body).
- It can achieve multiple inheritances.
- If a class implements 2 interfaces and they have same methods, then only one implementation is required.
- Interfaces can be declared as private, protected or transient.
- Interface by default abstract and public.
- Variables declared in interface are public, static, final by default.
- Interface variables must be initialized at the time of declaration otherwise compiler will throw an error.
- Inside any implementation class, you cannot change the variables declared in an interface.
- Variable name conflict can be resolved by Interface name. For instance, Interface A and B have variable x, then access it as A.x nand B.x.

Eg:
public interface Try{
    int a = 10; //valid
    public int b = 10; //valid
    public static final int c = 10; //valid
    final int d = 10; //valid
    static int e = 10; //valid
    int x; //invalid
}

Q. What are nested interfaces?

Q. Why use interfaces when we have abstract classes?
-> The reason is, abstract classes may contain non-final variables, whereas variables in the interface are final, public, and static.

Abstract class:
abstract class Animal {
    abstract void makeSound();     // Abstract method (no body)

    void sleep() {            // Concrete method with implementation
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof! Woof!");
    }
}

public class AbstractClassExample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound(); // Outputs: Woof! Woof!
        dog.sleep();     // Outputs: Sleeping...
    }
}

Interface:
interface Animal {
    void makeSound();        // Abstract methods (implicitly public and abstract)

    default void sleep() {         // Default method with implementation (introduced in Java 8)
        System.out.println("Sleeping...");
    }
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof! Woof!");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound(); // Outputs: Woof! Woof!
        dog.sleep();     // Outputs: Sleeping...
    }
}

Diff between Abstract class and Interfaces:
1. Purpose: Abstract classes share behavior among related classes; interfaces define a contract for unrelated classes.  
2. Inheritance: Abstract classes support single inheritance; interfaces support multiple inheritance.  
3. Methods: Abstract classes can have abstract and concrete methods; interfaces can only have abstract methods (default and static from Java 8).  
4. Access Modifiers: Abstract classes allow private, protected, or public methods; interfaces have `public abstract` methods by default.  
5. Constructors: Abstract classes can have constructors; interfaces cannot.  
6. Fields: Abstract classes can have instance variables; interfaces only allow `public static final` constants.  
7. Use Case: Abstract classes are for shared code; interfaces are for enforcing behavior.  
8. Performance: Abstract classes are slightly faster; interfaces were slower before Java 8 due to dynamic resolution.  

###Summary:  
Use an abstract class when you need shared code and behavior among related classes. 
Use an **interface** when you want to define a set of rules that multiple unrelated classes should implement.

* Polymorphism
1. Compile Time polymorphism:
There are 3 types:
a. Method Overloading
b. Operator Overloading
c. Template 

A. Method overloading (multiple methods with the same name but different parameters)
(method signature is method name and method parameter)
=> class Helper {
    static int Multiply(int a, int b)     // Method with 2 integer parameters
    {
        return a * b; // Returns product of integer numbers
    }
    
    static double Multiply(double a, double b) // With same name but with 2 double parameters
    {
        return a * b; // Returns product of double numbers
    }
}

B. Operator Overloading (not supported in Java)
class Complex {
private:
    int real, imag;

public:
    Complex(int r = 0, int i = 0)
    {
        real = r;
        imag = i;
    }
    void print() { cout << real << " + i" << imag << endl; }
    friend Complex operator+(Complex const& c1, Complex const& c2); //The global operator function is made friend of this class so that it can access private members
};

Complex operator+(Complex const& c1, Complex const& c2) { 
    return Complex(c1.real + c2.real, c1.imag + c2.imag); 
}

int main() {
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2; // An example call to &quot;operator+&quot;
    c3.print();
    return 0;
}

C. Template class (not supported in java)
template <typename T> T myMax(T x, T y) { // One function works for all data types. This would work even for user defined types if operator '>' is overloaded
    return (x > y) ? x : y;
}

int main() {
    cout << myMax<int>(3, 7) << endl;  // Call myMax for int
    cout << myMax<double>(3.0, 7.0) << endl; // call myMax for double
    cout << myMax<char>('g', 'e') << endl; // call myMax for char
    return 0;
}

2. Run Time polymorphism (Dynamic Method Dispatch): 
A function call to the overridden method is resolved at Runtime. 
-> Method Overriding
   - Methods with same signature and name are overriden from the inherited class.
   - The argument list of the child class should match the parent class
   - Access modifier of the child class should be less restrictive than the parent class

class Parent {
    void Print() {  System.out.println("parent class"); }
}

class subclass1 extends Parent {
    void Print() { System.out.println("subclass1"); }
}

class subclass2 extends Parent {
    void Print() { System.out.println("subclass2"); }
}

class GFG {
    public static void main(String[] args)
    {
        Parent a; // Creating object of class 1   

        a = new subclass1();
        a.Print();

        a = new subclass2();
        a.Print();
    }
}
Output
subclass1
subclass2

* Erros Vs Exception:
- Both Errors and Exceptions are the subclasses of java.lang.Throwable class 
- Errors are usually caused by serious problems that are outside the control of program such as running out of memory or system crash.
- Erros Eg: OutOfMemoryError, StackOverflowError, NoClassDefFoundError.
- Cannot recover from some of the errors.
- Exceptions, are used to handle the errors that can occur during program execution.
- Exception Eg: NullPointerException, IllegalArgumentException, IOException.
- Since exceptions can be caught and handled, it is common to include code to handle exceptions.
- Errors are of Unchecked type. Exceptions can be Checked or Unchecked type.

~ Checked Exceptions: checked by compiler at compile time. cannot be ignored, programmer should handle these exceptions.
~ Unchecked Exceptions: exceptions that occur at the time of execution. Run-time exceptions.

* Exception handling methods:
try-catch (handle exceptions), finally (runs regardless of whether an exception is thrown or caught), 
throw (explicitly raise exceptions), and throws (declare exceptions in method signatures)

* Final vs Finally vs Finalise
Final: A keyword and access modifier. Final variable becomes constant. Final method cannot be overridden. Final class cannot be inherited.
Finally: finally block runs even if exception occurs or not.
Finalize: finalise method performs cleaning activities with respect to object before its destruction.

* Java Enumeration:
Java enums -> fixed set of constants or variables that do not tend to change. static and final implicitly.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. Arrays and Strings

* Types of Sorting algorithm:
1. Bubble Sort (swapping adjacent elements if they are in a wrong sequence)
void bubbleSort(int arr[]){
    int n = arr.length;
    for(int i = 0; i < n - 1; i++){
        for(int j = 0; j < n - 1; j++){
            if(arr[j] > arr[j + 1]){
                int tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
}

2. Selection Sort (find the minimum element and put it in the beginning)
void selectionSort(int arr[]){
    int n = arr.length;
    for(int i = 0; i < n - 1; i++){
        int minIdx = i;  //assuming min index is at ith element

        for(int j = i + 1; j < n; j++){
            if(arr[j] < arr[minIdx]){
                minIdx = j;
            }
        }

        int tmp = arr[minIdx];
        arr[minIdx] = arr[i];
        arr[i] = tmp;
    }
}

3. Insertion Sort (Inserting an element in its right position)
void selectionSort(int arr[]){
    int n = arr.length;
    for(int i = 0; i < n; i++){
        int key = arr[i];  
        int j = i - 1;

        // Move elements of arr[0..i-1], that are greater than key,
        // to one position ahead of their current position
        while(j >= 0 && arr[j] > key){
            arr[j + 1] = arr[j];
            j = j - 1;
        }

        arr[j + 1] = key;
    }
}

4. Quick Sort (Select a pivot, partition the array into elements less than and greater than the pivot)
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        // Partition the array and get the pivot index
        int pivotIndex = partition(arr, low, high);

        // Recursively sort the subarrays
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

public static int partition(int[] arr, int low, int high) {
    int pivot = arr[high]; // Choose the last element as pivot
    int i = low - 1;       // Index of smaller element

    for (int j = low; j < high; j++) {
        // If current element is smaller than the pivot
        if (arr[j] < pivot) {
            i++;
            // Swap arr[i] and arr[j]
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    // Swap arr[i+1] and arr[high] (pivot)
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    return i + 1; // Return the pivot index
}

5. Merge Sort (Recursively divide the array into halves, sort each half, and merge the sorted halves back together.)
public static void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        // Recursively sort the left and right halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Merge the sorted halves
        merge(arr, left, mid, right);
    }
}

// Merge function to combine two sorted subarrays
public static void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1; // Size of the left subarray
    int n2 = right - mid;    // Size of the right subarray

    // Temporary arrays
    int[] leftArray = new int[n1];
    int[] rightArray = new int[n2];

    // Copy data to temporary arrays
    for (int i = 0; i < n1; i++) {
        leftArray[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        rightArray[j] = arr[mid + 1 + j];
    }

    // Merge the temporary arrays back into the original array
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (leftArray[i] <= rightArray[j]) {
            arr[k] = leftArray[i];
            i++;
        } else {
            arr[k] = rightArray[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of leftArray, if any
    while (i < n1) {
        arr[k] = leftArray[i];
        i++;
        k++;
    }

    // Copy remaining elements of rightArray, if any
    while (j < n2) {
        arr[k] = rightArray[j];
        j++;
        k++;
    }
}

* Types of Searching algorithm:
1. Linear Search (Sequentially check each element until the target is found or the end is reached)
public static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i; // Return index of the target
        }
    }
    return -1; // Return -1 if target not found
}

2. Binary Search (Repeatedly divide the sorted array in half, comparing the target with the middle element, until the target is found or the search space is empty)
public static int binarySearch(int[] arr, int target) {
    int low = 0, high = arr.length - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == target) {
            return mid; // Target found
        } else if (arr[mid] < target) {
            low = mid + 1; // Search in the right half
        } else {
            high = mid - 1; // Search in the left half
        }
    }
    return -1; // Target not found
}

* Operations performed on ArrayList
add(E e): Appends the specified element to the end of the list.
add(int index, E element): Inserts the specified element at the specified position in the list.
get(int index): Returns the element at the specified index.
set(int index, E element): Replaces the element at the specified index with the specified element.
remove(int index): Removes the element at the specified position in the list.
remove(Object o): Removes the first occurrence of the specified element from the list.
clear(): Removes all elements from the list.
size(): Returns the number of elements in the list.
contains(Object o): Checks if the list contains the specified element.
indexOf(Object o): Returns the index of the first occurrence of the specified element.
lastIndexOf(Object o): Returns the index of the last occurrence of the specified element.
isEmpty(): Checks if the list is empty.
trimToSize(): Reduces the size of the ArrayList to the current number of elements.
clone(): Creates a shallow copy of the ArrayList.
toArray(): Converts the ArrayList into an array.

* Java Strings:
- String is a java object representing a sequence of characters. 
- java.lang.String class is used to create and manipulate strings.
- String is immutable in nature.

* Java Strings class implements these interfaces: Serializable, Comparable, Charsequence
- Serializable: Allows the String object to be serialized, meaning it can be converted into a byte stream, which can then be stored or transmitted.
- Comparable: Allows String objects to be compared to each other.
- Charsequence: provides methods for working with character sequences, such as charAt(), length(), and subSequence().

Charsequence is a parent interface to String, StringBuilder, StringBuffer.
// Run Time polymorphism
CharSequence cs = null;
cs = new String("Hello");
cs = new StringBuilder("Hi");
cs = new StringBuffer("Bye");

* String vs String Buffer vs String Builder

* String pool
- Java String pool refers to the collection of Strings which are stored in heap memory.
- As String objects are immutable in nature, thus string pool came into picture.
- String pool helps in saving space for Java runtime.

Creating a String:
1. Using literals (stored in String pool)
  Eg: 
        String str = "Java"; // a new string literal created in string pool and is referenced by str
        String str1 = "Java"; // same literal created above is referenced by str1
        String str2 = "OOPs";  // a new string literal created in string pool and is referenced by str2

2. Creating a new object on Heap Memory
  Eg: String str = new String("Java");

| Feature       | ==                                           | .equals()                   | .compareTo()                     |
|---------------|----------------------------------------------|-----------------------------|----------------------------------|
| Type          | Operator                                     | Method                      | Method                           |
| Checks        | Memory reference (or value for primitives)   | Logical equality (content)  | Lexicographical or natural order |
| Return Type   | boolean                                      | boolean                     | int                              |
| Usage         | Primitive comparison or reference comparison | Content comparison          | Ordering or sorting              |

String str1 = "Hello"
String str2 = "Hello"
String str3 = new String("Hello");
String str4 = new String("Hello");

str1 == str2 ==> TRUE
str1.equals(str2) ==> TRUE
str1 == str3 ==> FALSE
str3 == str4 ==> FALSE
str3.equals(str4) ==> TRUE
str2.equals(str3) ==> TRUE
str3.compareTo(str4) ==> 0

str1.toUpperCase() //no change as strings are immutable, i.e. str1 will still be "Hello"
String str5 = str1.toUpperCase() // str5 will be "HELLO"

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4. Java Data Structure

### 1. Arrays: A fixed-size container declared at the time of creation to store elements of the same type.
- Fast access by index.
- Syntax:
  int[] arr = new int[5];
  int[] arr = {1, 2, 3, 4, 5};
- Advantages: Direct indexing provides O(1) access.
- Limitations: Fixed size and no direct support for dynamic resizing.

### 2. ArrayList: A resizable array-like data structure provided by `java.util`.
- Allows dynamic resizing.
- Supports generics.
- Provides many utility methods.
- Syntax:
  ArrayList<Integer> list = new ArrayList<>();
  list.add(1);
  list.remove(0);
- Time Complexity:
  - Access: O(1)
  - Insert/Delete: O(n) (shifting may occur)

### 3. LinkedList: A doubly linked list implementation in Java.
- Nodes store data and pointers to the next and previous elements.
- Syntax:
  LinkedList<String> list = new LinkedList<>();
  list.add("A");
  list.addFirst("B");
  list.addLast("C");
- Advantages: Efficient insertions/deletions (O(1) if the position is known).
- Disadvantages: Slower access time compared to arrays (O(n)).

### 4. HashMap: A key-value pair data structure based on a hash table.
- Allows fast retrieval using keys.
- Does not guarantee order.
- Syntax:
  HashMap<String, Integer> map = new HashMap<>();
  map.put("Alice", 25);
  map.get("Alice");
- Time Complexity:
  - Average: O(1) for get/put.
  - Worst: O(n) (in case of hash collisions).

### 5. TreeMap: A key-value pair data structure based on a Red-Black Tree.
- Keys are sorted in natural order or by a custom comparator.
- Syntax:
  TreeMap<String, Integer> map = new TreeMap<>();
  map.put("Alice", 25);
  map.firstKey();
- Time Complexity:
  - O(log n) for get/put operations.

### 6. Stack: A Last-In-First-Out (LIFO) data structure.
- Use the `java.util.Stack` class.
- Syntax:
  Stack<Integer> stack = new Stack<>();
  stack.push(1);
  stack.pop();
  stack.peek();

- Time Complexity:
  - Push/Pop: O(1)

### 7. Queue: A First-In-First-Out (FIFO) data structure.
- Uses `LinkedList` or `PriorityQueue` for implementation.
- Syntax:
  Queue<Integer> queue = new LinkedList<>();
  queue.add(1);
  queue.poll();
  queue.peek();
- Types:
  - PriorityQueue: Ordered based on priority.
  - Deque: Double-ended queue allowing insertion/removal at both ends.

### 8. HashSet: A collection for storing unique elements.
- Based on a hash table.
- No duplicate elements.
- Syntax:
  HashSet<Integer> set = new HashSet<>();
  set.add(1);
  set.contains(1);
- Advantages: Fast lookup and insertion (O(1) average).

### 9. TreeSet: A `Set` implementation based on a Red-Black Tree.
- Stores elements in sorted order.
- Syntax:
  TreeSet<Integer> set = new TreeSet<>();
  set.add(1);
  set.first();
  set.last();
- Time Complexity:
  - O(log n) for add/remove/search.

### 10. PriorityQueue: A queue where elements are processed based on priority.
- By default, natural ordering is used, but a custom comparator can be provided.
- Syntax:
  PriorityQueue<Integer> pq = new PriorityQueue<>();
  pq.add(5);
  pq.poll(); // Retrieves and removes the head.
- Time Complexity:
  - O(log n) for insertion and removal.

### Choosing the Right Data Structure
| Use Case                              | Recommended Data Structure |
|---------------------------------------|----------------------------|
| Random access with fixed size         | Array                      |
| Dynamic resizing                      | ArrayList                  |
| Frequent insertions/deletions         | LinkedList                 |
| Key-value storage                     | HashMap, TreeMap           |
| Unique elements                       | HashSet, TreeSet           |
| LIFO operations                       | Stack                      |
| FIFO operations                       | Queue                      |
| Priority-based operations             | PriorityQueue              |


* Generics in Java 

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5. File Handling

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

6. Object Serialization
- process of converting java code object into byte stream, to transfer the object code from 1 JVM to another and recreate it there using the process of Deserialization.
- we need serialization for communication, persistence, deep copy, caching, cross jvm synchronisation.
- need to implement following interfaces: java.io.Serializable, java.io.Externalizable.
- If a class implements serializable, then its subclasses are also serializable.
- Serialization of static member field is ignored in the process of Serialization. Serialization is related to the object's latest state hence only the date associated
to the latest state is serialized but not the static member field.

* Externizable Interface:
- It extends the Serializable interface and is a part of the java.io package and is used to customize the serialization and deserialization process of objects.
- It allows complete control over the serialization process by requiring explicit implementation of read and write operations.
- The class implementing Externalizable must have a public no-argument constructor, as it is used during deserialization.
- Used when you need precise control over the serialization process.
- Allows you to serialize only selected fields or perform additional logic during serialization/deserialization.

* Transient Keyword:
- used as a variable modifier at the time of Serialization process. It avoids the variable to be serialized.

* Serial version UID
Serialized objects get associated with a unique identification number provided by the JVM of the host machine.
This unique ID is called Serial Version UID.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7. Java Threads
CPU -> brain of computer, responsible for executing instructions from programs. Performs operations specified by instructions.
Eg: Intel Core i7, AMD Ryzen 7.

Core -> an individual processing unit within CPU. Modern CPUs have multiple cores for multi-tasking.

Program -> Set of instructions written in a programming language. 
Eg: Microsoft Word is a program that allows users to create and edit documents.

Process -> Instance of program that is being executed. When a program runs, the OS creates a process to manage its execution.

Thread -> Smallest unit of execution within a process. A process can have multiple threads, which share the same resources but can run independently.
Eg: Google chrome uses multiple threads for operating different tabs.

Multi Tasking: Allows OS to run multiple processes simultaneously.
On single-core, this is done using time slicing and context switching between tasks.
On multi-core, parallel execution occurs, with tasks distributed across cores.
The OS scheduler balances the load, ensuring efficient and responsive system performance.
Managing completely separate programs which may have independent memory spaces & system resources. 
Eg: Office Manager, assigns different teams to work on different projects.

Time Slicing: divides CPU time into small intervals called time slices or quanta.
Context Switching: saving the state of currently running process or thread and loading the state of next one to be executed.

Multi Threading: Ability to execute multiple threads within a single process concurrently.
Managing resources within a single program, where threads share the memory and resources.
Eg: A Team Lead, assigns different teams to work on same project.

* Java Multithreading: 
- concurrent execution of 2 or more threads to maximise CPU utilisation.
- single-core: multithreading managed by JVM and OS, the switch between threads to give the illusion of concurrency.
- multi-core: JVM distributes threads across multiple cores, allowing true parallel execution.
- Java supports multithreading through its Java.lang.Thread class and Java.lang.Runnable interface.
- Java program starts main thread starts executing immediately. And the thread executes main method of the program.

* Create a new Thread:
Way 1. Extend Thread class. Override the run method and define code. Use start method to initiate the new thread.
Way 2. Implement Runnable interface. Override the run method and define code. Create a Thread object by passing an instance of new class. 
       Use start method to initiate the new thread.

Lifecycle of Thread:
New: created but not yet started.
Runnable: after start method is called and is waiting for CPU time.
Running: when it is executing.
Blocked/Waiting: waiting for another thread to complete.
Terminated: when finished execution.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8. Regular Expressions:
- Sequence of characters that construct a search pattern.

Eg: ^[a-z0-9_-]{3,15}$
^: Indicates the start of the string.
[a-z0-9_-]: This is a character set that allows lowercase alphabets (a-z), digits (0-9), underscores (_), and hyphens (-).
{3,15}: This specifies that the preceding character set must appear at least 3 times and at most 15 times.
$: Indicates the end of the string.

Java Regex: API used to define a pattern for searching or manipulating Strings. Used to define constraints on passwords or emails.
Here are the key methods of the `Matcher` class:
1. matches(): Checks if the entire input sequence matches the pattern.  
2. find(): Finds the next subsequence of the input that matches the pattern.  
3. lookingAt(): Checks if the beginning of the input matches the pattern.  
4. start(): Returns the start index of the current match.  
5. end(): Returns the end index (exclusive) of the current match.  
6. group(): Returns the matched subsequence.  
7. replaceAll(String replacement): Replaces every match with the given replacement string.  
8. replaceFirst(String replacement): Replaces the first match with the given replacement string.  
9. groupCount(): Returns the number of capturing groups in the pattern.  
10.reset(): Resets the matcher, optionally with a new input sequence.  


The top 5 commonly used methods of the `Pattern` class are:
1. compile(String regex): Compiles the given regular expression into a `Pattern`.  
2. matcher(CharSequence input): Creates a `Matcher` object for matching the input sequence against the pattern.  
3. split(CharSequence input): Splits the input sequence into an array using the pattern as the delimiter.  
4. pattern(): Returns the regular expression as a string.  
5. flags(): Returns the match flags used to compile the pattern.  

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9. Socket Programming
- Used for communication between the application that is running on different JRE. It can be either connection-oriented or connectionless.
-  

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10. Design Patterns ->  a template to solve a problem that occurs in multiple instances while designing a Software Application.
* Why do we need Design patterns?
- OOP Solutions
- Easy to Maintain
- Efficient

* Types of Design Patterns:

A. Creational Design Patterns: focus on how objects are created, ensuring flexibility and reuse.

1. Singleton: define a class has only one instance and provides a global access point to it.  
    A singleton class is:
    - Declare a private static variable to hold the single instance of the class.
    - Make the constructor of the class private, so that no other instances can be created.
    - Provide a public static method to return the single instance of the class, creating it if necessary.
    public class Singleton {  
        private static Singleton instance;  
        private Singleton() {}  
        public static synchronized Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
        }  
    }

2. Factory Method: Defines an interface for creating objects but lets subclasses decide which class to instantiate.
3. Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.  
4. Builder: Constructs a complex object step by step and allows customization of the construction process.  
5. Prototype: Creates new objects by copying an existing object (prototype).  

- Structural Design Patterns: focus on object composition and simplify the structure by identifying relationships.  
1. Adapter: Allows incompatible interfaces to work together.  
2. Bridge: Separates an object’s abstraction from its implementation.  
3. Composite: Composes objects into tree structures to represent part-whole hierarchies.  
4. Decorator: Dynamically adds behavior or responsibilities to objects.  
5. Facade: Provides a simplified interface to a larger body of code.  
6. Flyweight: Reduces memory usage by sharing objects instead of creating new ones.  
7. Proxy: Provides a placeholder or surrogate to control access to an object.  

- Behavioral Design Patterns: focus on object interaction and responsibility distribution.  
1. Chain of Responsibility: Passes requests along a chain of handlers until one handles the request.  
2. Command: Encapsulates a request as an object, allowing parameterization and queuing.  
3. Interpreter: Implements a language grammar or syntax.  
4. Iterator: Provides a way to access elements of a collection sequentially without exposing its underlying structure.  
5. Mediator: Centralizes communication between objects.  
6. Memento: Captures and restores an object's state without revealing its implementation.  
7. Observer: Defines a dependency between objects so that when one changes state, all dependents are notified.  
8. State: Encapsulates state-specific behavior in separate classes and delegates to the current state.  
9. Strategy: Defines a family of algorithms and makes them interchangeable.  
10. Template Method: Defines the skeleton of an algorithm in a base class but allows steps to be overridden in subclasses.  
11. Visitor: Separates algorithms from object structure by moving the logic into visitor classes.  

- JEE Design Patterns:
1. Presentation Tier Patterns:  
   - Intercepting Filter: Filters requests and responses to perform pre-processing or post-processing.  
   - Front Controller: Provides a centralized entry point to handle requests.  
   - View Helper: Separates view-related code from business logic.  
   - Composite View: Creates views from multiple subviews.  
   - Service to Worker: Combines Front Controller and View Helper patterns.  

2. Business Tier Patterns:  
   - Business Delegate: Reduces coupling between presentation and business tiers.  
   - Service Locator: Provides a single point of control to locate and retrieve services.  
   - Session Facade: Simplifies interactions between clients and the business layer.  
   - Application Service: Centralizes and manages business logic.  

3. Integration Tier Patterns:  
   - Data Access Object (DAO): Encapsulates database access and operations.  
   - Service Activator: Processes asynchronous requests.  

4. Concurrency Patterns:  
   - Thread Pool: Manages a pool of threads for resource optimization.  
   - Work Queue: Processes tasks asynchronously.  

-------------------------------------------------------------------------------------**THE END**----------------------------------------------------------------------------------------------------------------------
